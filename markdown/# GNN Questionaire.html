<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>gnn-questionaire</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="# GNN Questionaire_files/libs/clipboard/clipboard.min.js"></script>
<script src="# GNN Questionaire_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="# GNN Questionaire_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="# GNN Questionaire_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="# GNN Questionaire_files/libs/quarto-html/popper.min.js"></script>
<script src="# GNN Questionaire_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="# GNN Questionaire_files/libs/quarto-html/anchor.min.js"></script>
<link href="# GNN Questionaire_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="# GNN Questionaire_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="# GNN Questionaire_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="# GNN Questionaire_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="# GNN Questionaire_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="gnn-questionaire" class="level1">
<h1>GNN Questionaire</h1>
<section id="how-experienced-are-you-with-graph-models" class="level2">
<h2 class="anchored" data-anchor-id="how-experienced-are-you-with-graph-models">How experienced are you with graph models?</h2>
<p>I have been working on graph models since 2015 officially. In other words, 10 years of experiences with close to 10 products delivered, in various application domains.</p>
</section>
<section id="what-type-of-graph-models-have-you-worked-with" class="level2">
<h2 class="anchored" data-anchor-id="what-type-of-graph-models-have-you-worked-with">What type of graph models have you worked with?</h2>
<p>This question has casted an extremely wide net.</p>
<p>From the graph theoretic point of view, I have worked on directed/undirected graphs Weighted/unweighted graphs Simple/multigraphs Bipartite graphs Tree/Fores types of graphs Causal/Bayesian graph models, etc.</p>
<p>From Machine Learning point of view, I have worked on GNNs, including GCN and GAT Graph Embedding Models Knowledge Graphs Temporal-spatial graph models, etc.</p>
</section>
<section id="have-you-built-your-own-model-from-scratch" class="level2">
<h2 class="anchored" data-anchor-id="have-you-built-your-own-model-from-scratch">Have you built your own model from scratch?</h2>
<p>I have always built models from scratch because I am working at the Tech Center of a Federal Funded Research and Development Center (FFRDC). My major efforts are writing research proposals and built proof-of-concepts to solve realistic business challenges. None of these solutions had existing solutions. Or, the existing solutions were not satisfactory.</p>
</section>
<section id="what-was-the-complexity-of-those-models" class="level2">
<h2 class="anchored" data-anchor-id="what-was-the-complexity-of-those-models">What was the complexity of those models?</h2>
<p>There are two types of models are extremely complex Temporal-spatial multigraphs. For example, traffics flows of the National Air Space, considering dynamic space partition, traffic conflicts, severe weather disturbances, etc. Knowledge graph for conceptual reasoning in legal or financial domains.</p>
</section>
<section id="what-is-the-number-of-nodes-and-the-number-of-features-in-the-graph-you-have-worked-with" class="level2">
<h2 class="anchored" data-anchor-id="what-is-the-number-of-nodes-and-the-number-of-features-in-the-graph-you-have-worked-with">What is the number of nodes and the number of features in the graph you have worked with?</h2>
<p>Multi-graph with hundreds nodes and thousands edges. Number of features varying from several to several dozens. For example, the global network traffics between data centers supporting distributed applications is known to be NP-hard. So is the architecture auto-design models.</p>
</section>
<section id="can-you-describe-a-gnn-project-you-built-from-scratch-what-problem-were-you-solving-and-what-architecture-choices-did-you-make" class="level2">
<h2 class="anchored" data-anchor-id="can-you-describe-a-gnn-project-you-built-from-scratch-what-problem-were-you-solving-and-what-architecture-choices-did-you-make">Can you describe a GNN project you built from scratch? What problem were you solving, and what architecture choices did you make?</h2>
<p>Here is an example. Big organizations, like Microsoft or Department of Defense, have to operate dozens of data centers across the globe. For many reasons, they have high priority distributed applications that are running across several data centers. On the other hand, network communication bandwidth is always limited. To effectively support all types of data traffic among these data centers is known to be a NP-hard optimization challenge on large scale graphs. For the purpose of resilience, the operator shall be able to re-route the traffics on-the-fly without disrupt the operations whenever network disturbance happens. Traditional network optimization will take more than a month to reach a viable re-route solution even on massive HPC clusters. This certainly is not practical.</p>
<p>Exhaustively search the entire solution space (a.k.a., global optimal) is theoretically impossible. After broad search, we picked a sub-optimal solution within a controlled sub-space. Such a space is identified using traditional graph algorithms. GNN is adopted to encode this sub-space as well as traffic patterns. Afterwards, multi-agent reinforcement learning is adopted to find optimal policies between each pair of data centers. We have further extend the solutions to make sure high priority (distribution) applications will always supported and can be dynamically relocated on-demand.</p>
</section>
<section id="have-you-applied-gnns-to-reasoning-over-complex-relational-or-hierarchical-data-like-molecules-infrastructure-or-3d-models" class="level2">
<h2 class="anchored" data-anchor-id="have-you-applied-gnns-to-reasoning-over-complex-relational-or-hierarchical-data-like-molecules-infrastructure-or-3d-models">Have you applied GNNs to reasoning over complex relational or hierarchical data (like molecules, infrastructure, or 3D models)?</h2>
<p>Yes. The project of architecture auto design is a typical example. Out of thousands of candidate systems of various functions and varying specs, using RL and GNN, the AI solutions will put together all the necessary components as an extremely complex lego project. All these components not only have to be compatible with each other in capacities and requirements. The overall design has to be constrained and/or satisfy multiple multiple objectives. For example, function, cost, and construction schedule.</p>
</section>
<section id="have-you-worked-with-3d-reconstruction-meshes-or-spatial-reasoning-pipelines-how-did-you-structure-the-data-for-your-models" class="level2">
<h2 class="anchored" data-anchor-id="have-you-worked-with-3d-reconstruction-meshes-or-spatial-reasoning-pipelines-how-did-you-structure-the-data-for-your-models">Have you worked with 3D reconstruction, meshes, or spatial reasoning pipelines? How did you structure the data for your models?</h2>
<p>Yes. National Air Space is partitioned hierarchically into centers, tracons, and sectors horizontally, which are further partitioned into multiple layers vertically. The partitions are dynamically changing on-demand.</p>
</section>
<section id="in-this-project-there-are-three-major-data-objects.-traffic-flow-with-volume-possible-routes-with-available-capacity-and-hierarchical-space-partition-for-control-responsibilities-and-hand-offs.-at-the-interface-of-space-partitions-routes-has-to-be-continued-and-there-capacities-have-to-be-compatible.-in-addition-there-are-safety-constraints-have-to-be-met." class="level2">
<h2 class="anchored" data-anchor-id="in-this-project-there-are-three-major-data-objects.-traffic-flow-with-volume-possible-routes-with-available-capacity-and-hierarchical-space-partition-for-control-responsibilities-and-hand-offs.-at-the-interface-of-space-partitions-routes-has-to-be-continued-and-there-capacities-have-to-be-compatible.-in-addition-there-are-safety-constraints-have-to-be-met.">In this project, there are three major data objects. Traffic flow (with volume), possible routes (with available capacity), and hierarchical space partition (for control responsibilities and hand-offs). At the interface of space partitions, routes has to be continued and there capacities have to be compatible. In addition, there are safety constraints have to be met.</h2>
<p>In a nutshell, this can be modeled as network traffic allocation problem with dynamically configured network. Meanwhile, space partitions poses massive amounts of constraints on any chosen network configurations.</p>
</section>
<section id="have-you-applied-reinforcement-learning-in-combination-with-gnns-or-spatial-reasoning-systems-how-did-you-design-the-environment-and-reward" class="level2">
<h2 class="anchored" data-anchor-id="have-you-applied-reinforcement-learning-in-combination-with-gnns-or-spatial-reasoning-systems-how-did-you-design-the-environment-and-reward">Have you applied reinforcement learning in combination with GNNs or spatial reasoning systems? How did you design the environment and reward?</h2>
<p>I have used reinforcement learning in combination with GNN in architecture auto-design. I have also applied reinforcement learning in network traffic planning. However, not in spatial reasoning systems.</p>
</section>
<section id="if-you-were-asked-to-reason-about-placing-walls-or-components-in-a-3d-model-how-would-you-encode-the-rules-or-constraints-in-a-gnn." class="level2">
<h2 class="anchored" data-anchor-id="if-you-were-asked-to-reason-about-placing-walls-or-components-in-a-3d-model-how-would-you-encode-the-rules-or-constraints-in-a-gnn.">If you were asked to reason about placing walls or components in a 3D model, how would you encode the rules or constraints in a GNN.</h2>
<p>Equivariant GNNs (EGNNs) seems to be designed for this kind of applications.</p>
<p>In addition, If number of constraints are small, constraint-aware loss functions can be straightforward. If number of constraints are massive, Projected Gradient Descent (PGD) would be reasonable.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>